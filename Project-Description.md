# Project description

The field this domain-specific language would aim to cater to is that of mathematics, more specifically the domain of trigonometry. Be it digital imaging or modern architecture, music or video game design – the crucial importance of trigonometry cannot be underplayed. Almost all introductory as well as intermediate courses in trigonometry tend to include a certain sub-domain which is found in several areas of mathematics, however, whose nature is extremely distinct from those other areas and is unique to trigonometry itself – that of trigonometric proofs. Trigonometry has a myriad of distinct identities and formulae, from compound angle identities to double angle identities, as well as a massive number of other identities which equate different trigonometric functions with each other through manipulation in terms of arithmetic operations. Learning how to verify trigonometric proofs and simplify trigonometric expressions is a skill necessary for students to learn for them to be able to comprehend and utilize the more complex uses of trigonometry; it is also a skill students are only able to improve through intensive and repetitive practice.

However, one often insurmountable predicament several students face when dealing with such problems is the absolute lack of mechanisms and methods to verify their work or even seek out a solution if they are stuck on a particular step on this process. This is the very problem this domain-specific language will aim to address. A DSL is the appropriate solution to this problem because of its quality of limited expressiveness and that of its programming-language nature. For one, this DSL for simulation would enable the domain-experts to save time and effort by utilizing jargon only comprehensible to them which allows for more efficient and faster computations. This DSL will act as a verifier for trigonometric proofs and a calculator for trigonometric simplifications. The demographic that shall benefit from this DSL will be school and university students, for whom this DSL will simplify the process of verifying their work and solutions immensely. It can be of great use to any students working with or learning trigonometric proofs, in order to solve a particular problem or even simply verify their own solution. This project is exceedingly interesting in that it is not the typical example of a DSL in terms of its usage of domain-specific jargon and vocabulary as well as its idea of what kind of methods and functions can be called on different objects.

There exist no other DSLs in the specific sub-domain of trigonometric proofs. However, from Scala.math and Python.math, Scala and Python’s own mathematical modules which can calculate sine, cosine, and tangent as well as arcsine, arccosine, and arctangent trigonometric functions and convert between degrees and radians as well as Spire, which has the same functionalities - there are several libraries in the broader domain of trigonometry. Since these are not in the same domain, however, they may not greatly influence my language’s design or implementation.

This DSL’s design would aim to be fluent and concise whilst simultaneously communicating the complete inputs and outputs as required. A simple equation demonstrating the two trigonometric expressions which need to be equated, along with the user’s request as to whether the right-hand side or left-hand side is to be solved could constitute a language in this program. When the program runs, the language will attempt to manipulate one side of the equation until it is equal to the other using a variety of trigonometric and arithmetic identities and formulae. For the process of verifying a proof, a program in this language could simply be inputting the two sides of the equation. When the program runs, it will intend to then output the shortest number of possible complete steps in order to perform the verification of that particular trigonometric identity. As mentioned earlier, one of the most interesting features of this DSL is that it would be exceedingly unconventional in terms of the nature of its nouns, verbs, adjectives, and adverbs. The nouns in this language would ideally be the different kinds of trigonometric functions: sine , cosine , tangent , arcsine , arccosine , and arctangent since these will be the different kinds of data which are manipulated in order to achieve the output of the steps of verification of a trigonometric proof. Verbs in this language will, to my comprehension, be somewhat of a DSL within themselves, in that they will essentially be a variety of arithmetic, trigonometric, and functional transformations performed on these trigonometric functions – such as the + operator for addition, the – operator for subtraction, the / operator for division, the * operator or a simply a number being multiplied by a function (as in 2*sine or simply 2sine) for multiplication, ^n to raise a function to the power n, using cosec, secant, and cotangent as reciprocals of the basic functions, etc. The adverbs, if they are not functions themselves, could often simply be integers and floats which are used to implement the verbs on the basic functions.

Due to this domain’s quality of limited expressiveness as well as its domain-focus, it will be limited in terms of what it can do. Hence any mathematical functions or otherwise which are not a part of this domain (e.g. attempts to differentiate, calculate the inverse of, or integrate functions) will incontrovertibly elicit syntax errors. Misspellings of sine, cosine, tangent, or any of the other nouns as well as attempting to perform invalid operations shall result in syntactical errors. One imperative logic error which could cause the program to crash due to the massive number of endless computations would occur if the user accidentally inputs an equation whose two sides are not in fact equal. In order to tackle this error, one check that would run at the beginning of each program in this language is to see whether or not the LHS and RHS of the equation are equal for 10-15 different values of x. If they differ for even one value, the program will immediately output that there is a logical error in that the two sides of the equation are not equal hence no steps can be used to verify this equality. Another thing that this language will ensure is that errors are classified basis their nature and thus it is easy to ensure that different error messages are output basis the same.
