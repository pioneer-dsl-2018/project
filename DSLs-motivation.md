A programming language is a formal set of vocabulary and grammatical rules used to define a set of specific instructions which can command a machine to perform certain kinds of tasks. Several different programming languages define their own syntax and keywords which are then converted to machine code to be comprehended and executed by a computer. Broadly, programming languages may be classified into two types: general-purpose programming languages (GPPL) and domain-specific languages (DSL). A general-purpose programming language is a versatile tool intended to be broadly applicable across a variety of multifaceted domains and uses; it lacks specialized features to tend to the needs of any individual domain. Common examples of the same are Python, Java, Scala, and C++.

A domain-specific language, on the contrary, is a specialized computer language of limited expressiveness designed to cater to the requirements of a particular domain. The purpose of a DSL is to enable domain-experts to more readily interact with their domain, allowing them to augment their productivity by defining specific functions to perform iterative tasks. While GPPLs enable proficient programmers to write arbitrary algorithms, DSLs are comparatively limited in their scope and capabilities – only focussing on representing the problems of and tasks required by a particular domain or area. DSLs with a well-defined domain thus enable users, i.e. domain experts to increase their productivity and improve communication by focussing on the domain’s specific jargon and syntax as well as catering to its specific problems while eliminating the need for the user to understand the intricate working and internal operations of the machine in doing so; this means that DSLs enable the user to focus on the interface while stripping away the need for them to comprehend the implementation. Examples of DSLs include AutoCad, Mathematica, SQL, Game Maker Language, HTML, and CSS.

One of the key characteristics of DSLs and what greatly differentiates them from GPPLs is their quality of limited expressiveness. The wide variety and range of functionalities of a GPPL, while increasing their usability, also tend to increase the difficulty of being able to learn and utilise it. A DSL only supports the least number of acceptable features required for a domain – this limited expressiveness is a direct manifestation of the primary intent of a DSL being to equip domain-experts who have little to no knowledge of programming with being able to better interact with and navigate their domain. The quality of limited expressiveness also tends to add the advantage of DSLs being more machine-efficient as compared to GPPLs.

The design of a DSL dictates its ease-of-use. In terms of design, the primary purpose of a DSL is to attain a relatively high degree of clarity. Often, this has two major implications in terms of the syntax of the language: utilising the jargon of the domain and most imperatively, maintaining a component of fluency. The specificity and terseness of professional jargon improves the efficiency of communication by increasing the information processing speed; implementing the same in a DSL enables complex problems to be solved in fewer steps as well as better and more effective communication between the language and the expert. Fluency, in terms of a DSL, is defined as the level of readability and resemblance borne by a DSL to human language. This often manifests itself as the degree to which a DSL’s nouns (used to define different forms of data) and verbs (used to define the operations performed on the data) fit together.

DSLs can further be classified broadly into two different types: internal DSLs and external DSLs. An internal DSL is essentially defined as a domain-specific language which greatly utilises and bases its design on the infrastructure of a host language; it builds domain-specific functions and semantics by using the tools and pillars provided by this existing framework. Often, internal DSLs are implemented as fluent libraries for the existing language. Only a small subset of the language’s features is used when implementing an internal DSL. An external DSL, on the other hand, is a stand-alone programming language, independent of a host language. As such, an external DSL develops and follows its own syntax and semantics. An example is the Cascading Style Sheet (CSS) used to define the style used to visualize an HTML document on a screen.

GPPLs and DSLs, instead of being binary values, exist on a spectrum. As a consequence of this, when creating a DSL, the implementer can often employ a series of techniques to make the language increasingly more ‘DSL-y’. What starts out as an API can be converted to an internal DSL by adding fluency. Several different techniques may be employed by the language implementer in order to do so. Function composition, i.e. the application of one function to the result of another, can be used to do so. When multiple functions need to be called on the same object consecutively, something which is the often the case in domain-specific languages where the types of objects are limited due to the requirements of the domain, method-chaining may be employed as well. Essentially, each method returns an object, therefore enabling the different functions to be chained together instead of requiring separate variables to store the intermediate results.

The next step to making a language more like a DSL is often the process of removing the “host flavour” wherein the implementer essentially attempts to reduce the degree of influence the syntax of the host language has on the syntax of the DSL. This can be done by utilising a variety of features, such as infix operators, literal extensions, as well as pre- and post-fix operators. Adding syntactic sugar, i.e. reducing the dependency on the host language and bringing the syntax as close to natural human language as is possible makes the DSL easier to comprehend for those domain-experts who might not be familiar with the fundamentals of the syntax of higher-level languages.

